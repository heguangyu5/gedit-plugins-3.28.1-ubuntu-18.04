/* job.c generated by valac 0.40.2, the Vala compiler
 * generated from job.vala, do not modify */

/*
* Copyright (C) 2015 The Lemon Man
*
* This program is free software; you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation; either version 2, or (at your option)
* any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program; if not, write to the Free Software
* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
*/


#include <glib.h>
#include <glib-object.h>
#include <string.h>
#include <stdlib.h>
#include <gio/gio.h>
#include <gedit/gedit-utils.h>
#include <glib/gstdio.h>
#include <gobject/gvaluecollector.h>


#define GEDIT_FIND_IN_FILES_PLUGIN_TYPE_IMATCHER (gedit_find_in_files_plugin_imatcher_get_type ())
#define GEDIT_FIND_IN_FILES_PLUGIN_IMATCHER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GEDIT_FIND_IN_FILES_PLUGIN_TYPE_IMATCHER, GeditFindInFilesPluginIMatcher))
#define GEDIT_FIND_IN_FILES_PLUGIN_IS_IMATCHER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GEDIT_FIND_IN_FILES_PLUGIN_TYPE_IMATCHER))
#define GEDIT_FIND_IN_FILES_PLUGIN_IMATCHER_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), GEDIT_FIND_IN_FILES_PLUGIN_TYPE_IMATCHER, GeditFindInFilesPluginIMatcherIface))

typedef struct _GeditFindInFilesPluginIMatcher GeditFindInFilesPluginIMatcher;
typedef struct _GeditFindInFilesPluginIMatcherIface GeditFindInFilesPluginIMatcherIface;

#define GEDIT_FIND_IN_FILES_PLUGIN_TYPE_RANGE (gedit_find_in_files_plugin_range_get_type ())
typedef struct _GeditFindInFilesPluginRange GeditFindInFilesPluginRange;

#define GEDIT_FIND_IN_FILES_PLUGIN_TYPE_BOOKMARK (gedit_find_in_files_plugin_bookmark_get_type ())
typedef struct _GeditFindInFilesPluginBookmark GeditFindInFilesPluginBookmark;

#define GEDIT_FIND_IN_FILES_PLUGIN_TYPE_RESULT (gedit_find_in_files_plugin_result_get_type ())
typedef struct _GeditFindInFilesPluginResult GeditFindInFilesPluginResult;
#define _g_free0(var) (var = (g_free (var), NULL))

#define GEDIT_FIND_IN_FILES_PLUGIN_TYPE_FIND_JOB (gedit_find_in_files_plugin_find_job_get_type ())
#define GEDIT_FIND_IN_FILES_PLUGIN_FIND_JOB(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GEDIT_FIND_IN_FILES_PLUGIN_TYPE_FIND_JOB, GeditFindInFilesPluginFindJob))
#define GEDIT_FIND_IN_FILES_PLUGIN_FIND_JOB_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), GEDIT_FIND_IN_FILES_PLUGIN_TYPE_FIND_JOB, GeditFindInFilesPluginFindJobClass))
#define GEDIT_FIND_IN_FILES_PLUGIN_IS_FIND_JOB(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GEDIT_FIND_IN_FILES_PLUGIN_TYPE_FIND_JOB))
#define GEDIT_FIND_IN_FILES_PLUGIN_IS_FIND_JOB_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GEDIT_FIND_IN_FILES_PLUGIN_TYPE_FIND_JOB))
#define GEDIT_FIND_IN_FILES_PLUGIN_FIND_JOB_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), GEDIT_FIND_IN_FILES_PLUGIN_TYPE_FIND_JOB, GeditFindInFilesPluginFindJobClass))

typedef struct _GeditFindInFilesPluginFindJob GeditFindInFilesPluginFindJob;
typedef struct _GeditFindInFilesPluginFindJobClass GeditFindInFilesPluginFindJobClass;
typedef struct _GeditFindInFilesPluginFindJobPrivate GeditFindInFilesPluginFindJobPrivate;
#define _g_async_queue_unref0(var) ((var == NULL) ? NULL : (var = (g_async_queue_unref (var), NULL)))
#define __g_list_free__g_thread_unref0_0(var) ((var == NULL) ? NULL : (var = (_g_list_free__g_thread_unref0_ (var), NULL)))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))

#define GEDIT_FIND_IN_FILES_PLUGIN_TYPE_REGEX_FIND (gedit_find_in_files_plugin_regex_find_get_type ())
#define GEDIT_FIND_IN_FILES_PLUGIN_REGEX_FIND(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GEDIT_FIND_IN_FILES_PLUGIN_TYPE_REGEX_FIND, GeditFindInFilesPluginRegexFind))
#define GEDIT_FIND_IN_FILES_PLUGIN_REGEX_FIND_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), GEDIT_FIND_IN_FILES_PLUGIN_TYPE_REGEX_FIND, GeditFindInFilesPluginRegexFindClass))
#define GEDIT_FIND_IN_FILES_PLUGIN_IS_REGEX_FIND(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GEDIT_FIND_IN_FILES_PLUGIN_TYPE_REGEX_FIND))
#define GEDIT_FIND_IN_FILES_PLUGIN_IS_REGEX_FIND_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GEDIT_FIND_IN_FILES_PLUGIN_TYPE_REGEX_FIND))
#define GEDIT_FIND_IN_FILES_PLUGIN_REGEX_FIND_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), GEDIT_FIND_IN_FILES_PLUGIN_TYPE_REGEX_FIND, GeditFindInFilesPluginRegexFindClass))

typedef struct _GeditFindInFilesPluginRegexFind GeditFindInFilesPluginRegexFind;
typedef struct _GeditFindInFilesPluginRegexFindClass GeditFindInFilesPluginRegexFindClass;

#define GEDIT_FIND_IN_FILES_PLUGIN_TYPE_BOYER_MOORE_HORSPOOL (gedit_find_in_files_plugin_boyer_moore_horspool_get_type ())
#define GEDIT_FIND_IN_FILES_PLUGIN_BOYER_MOORE_HORSPOOL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GEDIT_FIND_IN_FILES_PLUGIN_TYPE_BOYER_MOORE_HORSPOOL, GeditFindInFilesPluginBoyerMooreHorspool))
#define GEDIT_FIND_IN_FILES_PLUGIN_BOYER_MOORE_HORSPOOL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), GEDIT_FIND_IN_FILES_PLUGIN_TYPE_BOYER_MOORE_HORSPOOL, GeditFindInFilesPluginBoyerMooreHorspoolClass))
#define GEDIT_FIND_IN_FILES_PLUGIN_IS_BOYER_MOORE_HORSPOOL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GEDIT_FIND_IN_FILES_PLUGIN_TYPE_BOYER_MOORE_HORSPOOL))
#define GEDIT_FIND_IN_FILES_PLUGIN_IS_BOYER_MOORE_HORSPOOL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GEDIT_FIND_IN_FILES_PLUGIN_TYPE_BOYER_MOORE_HORSPOOL))
#define GEDIT_FIND_IN_FILES_PLUGIN_BOYER_MOORE_HORSPOOL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), GEDIT_FIND_IN_FILES_PLUGIN_TYPE_BOYER_MOORE_HORSPOOL, GeditFindInFilesPluginBoyerMooreHorspoolClass))

typedef struct _GeditFindInFilesPluginBoyerMooreHorspool GeditFindInFilesPluginBoyerMooreHorspool;
typedef struct _GeditFindInFilesPluginBoyerMooreHorspoolClass GeditFindInFilesPluginBoyerMooreHorspoolClass;
#define _g_thread_unref0(var) ((var == NULL) ? NULL : (var = (g_thread_unref (var), NULL)))
#define _gedit_find_in_files_plugin_find_job_unref0(var) ((var == NULL) ? NULL : (var = (gedit_find_in_files_plugin_find_job_unref (var), NULL)))
#define _g_hash_table_unref0(var) ((var == NULL) ? NULL : (var = (g_hash_table_unref (var), NULL)))
#define __g_queue_free__g_object_unref0_0(var) ((var == NULL) ? NULL : (var = (_g_queue_free__g_object_unref0_ (var), NULL)))
#define __g_list_free__g_object_unref0_0(var) ((var == NULL) ? NULL : (var = (_g_list_free__g_object_unref0_ (var), NULL)))
typedef struct _GeditFindInFilesPluginFindJobExecuteData GeditFindInFilesPluginFindJobExecuteData;
#define _g_mapped_file_unref0(var) ((var == NULL) ? NULL : (var = (g_mapped_file_unref (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
typedef struct _GeditFindInFilesPluginParamSpecFindJob GeditFindInFilesPluginParamSpecFindJob;
enum  {
	GEDIT_FIND_IN_FILES_PLUGIN_FIND_JOB_ON_MATCH_FOUND_SIGNAL,
	GEDIT_FIND_IN_FILES_PLUGIN_FIND_JOB_ON_SEARCH_FINISHED_SIGNAL,
	GEDIT_FIND_IN_FILES_PLUGIN_FIND_JOB_NUM_SIGNALS
};
static guint gedit_find_in_files_plugin_find_job_signals[GEDIT_FIND_IN_FILES_PLUGIN_FIND_JOB_NUM_SIGNALS] = {0};
#define _vala_assert(expr, msg) if G_LIKELY (expr) ; else g_assertion_message_expr (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, msg);
#define _vala_return_if_fail(expr, msg) if G_LIKELY (expr) ; else { g_return_if_fail_warning (G_LOG_DOMAIN, G_STRFUNC, msg); return; }
#define _vala_return_val_if_fail(expr, msg, val) if G_LIKELY (expr) ; else { g_return_if_fail_warning (G_LOG_DOMAIN, G_STRFUNC, msg); return val; }
#define _vala_warn_if_fail(expr, msg) if G_LIKELY (expr) ; else g_warn_message (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, msg);

struct _GeditFindInFilesPluginRange {
	gsize from;
	gsize to;
};

struct _GeditFindInFilesPluginIMatcherIface {
	GTypeInterface parent_iface;
	gboolean (*has_match) (GeditFindInFilesPluginIMatcher* self, guint8* text, gsize text_length, gsize pos, GeditFindInFilesPluginRange* match);
};

struct _GeditFindInFilesPluginBookmark {
	gint line_number;
	gsize line_start;
	gsize line_length;
};

struct _GeditFindInFilesPluginResult {
	gchar* path;
	gsize line;
	gchar* context;
};

struct _GeditFindInFilesPluginFindJob {
	GTypeInstance parent_instance;
	volatile int ref_count;
	GeditFindInFilesPluginFindJobPrivate * priv;
	gboolean include_hidden;
	gboolean match_whole_word;
	gboolean ignore_case;
};

struct _GeditFindInFilesPluginFindJobClass {
	GTypeClass parent_class;
	void (*finalize) (GeditFindInFilesPluginFindJob *self);
};

struct _GeditFindInFilesPluginFindJobPrivate {
	GAsyncQueue* scan_queue;
	GList* thread_workers;
	guint running_workers;
	GRecMutex __lock_running_workers;
	GeditFindInFilesPluginIMatcher* matcher;
	GCancellable* cancellable;
	gchar* _needle;
};

struct _GeditFindInFilesPluginFindJobExecuteData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GTask* _async_result;
	GAsyncReadyCallback _callback_;
	gboolean _task_complete_;
	GeditFindInFilesPluginFindJob* self;
	gchar* root;
	GQueue* queue;
	GQueue* _tmp0_;
	GHashTable* visited;
	GHashFunc _tmp1_;
	GEqualFunc _tmp2_;
	GHashTable* _tmp3_;
	GQueue* _tmp4_;
	GFile* _tmp5_;
	GQueue* _tmp6_;
	GCancellable* _tmp7_;
	GFile* dir;
	GQueue* _tmp8_;
	gpointer _tmp9_;
	GFileEnumerator* e;
	GFile* _tmp10_;
	GFileEnumerator* _tmp11_;
	GList* files;
	GFileEnumerator* _tmp12_;
	GList* _tmp13_;
	GList* _tmp14_;
	GCancellable* _tmp15_;
	GList* _tmp16_;
	GList* file_collection;
	GList* file_it;
	GFileInfo* _tmp17_;
	GFileInfo* file;
	gboolean _tmp18_;
	gboolean _tmp19_;
	GFileInfo* _tmp20_;
	const gchar* _tmp21_;
	GFileInfo* _tmp22_;
	GFile* _file;
	GFile* _tmp23_;
	GFileInfo* _tmp24_;
	const gchar* _tmp25_;
	GFile* _tmp26_;
	GFileInfo* _tmp27_;
	GAsyncQueue* _tmp28_;
	GFile* _tmp29_;
	gchar* _tmp30_;
	GQueue* _tmp31_;
	GFile* _tmp32_;
	GFile* _tmp33_;
	GHashTable* _tmp34_;
	GFile* _tmp35_;
	gchar* _tmp36_;
	gchar* link_dest;
	GFile* _tmp37_;
	gchar* _tmp38_;
	gchar* _tmp39_;
	gchar* _tmp40_;
	gchar* _tmp41_;
	gboolean _tmp42_;
	const gchar* _tmp43_;
	GHashTable* _tmp44_;
	const gchar* _tmp45_;
	gboolean _tmp46_;
	const gchar* _tmp47_;
	gboolean _tmp48_;
	gboolean _tmp49_;
	const gchar* _tmp50_;
	GQueue* _tmp51_;
	const gchar* _tmp52_;
	GFile* _tmp53_;
	GError * _inner_error_;
};

struct _GeditFindInFilesPluginParamSpecFindJob {
	GParamSpec parent_instance;
};


static GType gedit_find_in_files_plugin_imatcher_type_id = 0;
static gpointer gedit_find_in_files_plugin_find_job_parent_class = NULL;
static GType gedit_find_in_files_plugin_find_job_type_id = 0;

GType gedit_find_in_files_plugin_range_get_type (void) G_GNUC_CONST;
GeditFindInFilesPluginRange* gedit_find_in_files_plugin_range_dup (const GeditFindInFilesPluginRange* self);
void gedit_find_in_files_plugin_range_free (GeditFindInFilesPluginRange* self);
GType gedit_find_in_files_plugin_imatcher_get_type (void) G_GNUC_CONST;
gboolean gedit_find_in_files_plugin_imatcher_has_match (GeditFindInFilesPluginIMatcher* self,
                                                        guint8* text,
                                                        gsize text_length,
                                                        gsize pos,
                                                        GeditFindInFilesPluginRange* match);
GType gedit_find_in_files_plugin_bookmark_get_type (void) G_GNUC_CONST;
GeditFindInFilesPluginBookmark* gedit_find_in_files_plugin_bookmark_dup (const GeditFindInFilesPluginBookmark* self);
void gedit_find_in_files_plugin_bookmark_free (GeditFindInFilesPluginBookmark* self);
GType gedit_find_in_files_plugin_result_get_type (void) G_GNUC_CONST;
GeditFindInFilesPluginResult* gedit_find_in_files_plugin_result_dup (const GeditFindInFilesPluginResult* self);
void gedit_find_in_files_plugin_result_free (GeditFindInFilesPluginResult* self);
void gedit_find_in_files_plugin_result_copy (const GeditFindInFilesPluginResult* self,
                                             GeditFindInFilesPluginResult* dest);
void gedit_find_in_files_plugin_result_destroy (GeditFindInFilesPluginResult* self);
gpointer gedit_find_in_files_plugin_find_job_ref (gpointer instance);
void gedit_find_in_files_plugin_find_job_unref (gpointer instance);
GParamSpec* gedit_find_in_files_plugin_param_spec_find_job (const gchar* name,
                                                            const gchar* nick,
                                                            const gchar* blurb,
                                                            GType object_type,
                                                            GParamFlags flags);
void gedit_find_in_files_plugin_value_set_find_job (GValue* value,
                                                    gpointer v_object);
void gedit_find_in_files_plugin_value_take_find_job (GValue* value,
                                                     gpointer v_object);
gpointer gedit_find_in_files_plugin_value_get_find_job (const GValue* value);
GType gedit_find_in_files_plugin_find_job_get_type (void) G_GNUC_CONST;
#define GEDIT_FIND_IN_FILES_PLUGIN_FIND_JOB_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), GEDIT_FIND_IN_FILES_PLUGIN_TYPE_FIND_JOB, GeditFindInFilesPluginFindJobPrivate))
static void _g_free0_ (gpointer var);
static void _g_thread_unref0_ (gpointer var);
static inline void _g_list_free__g_thread_unref0_ (GList* self);
static gint gedit_find_in_files_plugin_find_job_worker (GeditFindInFilesPluginFindJob* self);
static void gedit_find_in_files_plugin_find_job_scan_file (GeditFindInFilesPluginFindJob* self,
                                                    const gchar* path);
static gboolean _____lambda5_ (GeditFindInFilesPluginFindJob* self);
static gboolean ______lambda5__gsource_func (gpointer self);
GeditFindInFilesPluginFindJob* gedit_find_in_files_plugin_find_job_new (GCancellable* cancellable);
GeditFindInFilesPluginFindJob* gedit_find_in_files_plugin_find_job_construct (GType object_type,
                                                                              GCancellable* cancellable);
static void gedit_find_in_files_plugin_find_job_set_needle (GeditFindInFilesPluginFindJob* self,
                                                     const gchar* value);
void gedit_find_in_files_plugin_find_job_prepare (GeditFindInFilesPluginFindJob* self,
                                                  const gchar* needle,
                                                  gboolean is_regex,
                                                  GError** error);
GType gedit_find_in_files_plugin_regex_find_get_type (void) G_GNUC_CONST;
GeditFindInFilesPluginRegexFind* gedit_find_in_files_plugin_regex_find_new (const gchar* pattern,
                                                                            gboolean ignore_case,
                                                                            GError** error);
GeditFindInFilesPluginRegexFind* gedit_find_in_files_plugin_regex_find_construct (GType object_type,
                                                                                  const gchar* pattern,
                                                                                  gboolean ignore_case,
                                                                                  GError** error);
GeditFindInFilesPluginBoyerMooreHorspool* gedit_find_in_files_plugin_boyer_moore_horspool_new (const gchar* pattern_,
                                                                                               gboolean ignore_case_);
GeditFindInFilesPluginBoyerMooreHorspool* gedit_find_in_files_plugin_boyer_moore_horspool_construct (GType object_type,
                                                                                                     const gchar* pattern_,
                                                                                                     gboolean ignore_case_);
GType gedit_find_in_files_plugin_boyer_moore_horspool_get_type (void) G_GNUC_CONST;
static void gedit_find_in_files_plugin_find_job_start_workers_pool (GeditFindInFilesPluginFindJob* self);
static gpointer _gedit_find_in_files_plugin_find_job_worker_gthread_func (gpointer self);
gchar* gedit_find_in_files_plugin_find_job_extract_context (GeditFindInFilesPluginFindJob* self,
                                                            guint8* buffer,
                                                            GeditFindInFilesPluginRange* range);
void gedit_find_in_files_plugin_find_job_halt (GeditFindInFilesPluginFindJob* self);
static gboolean gedit_find_in_files_plugin_find_job_is_binary (GeditFindInFilesPluginFindJob* self,
                                                        guint8* buffer,
                                                        gsize buffer_size);
static gboolean gedit_find_in_files_plugin_find_job_ignore_vcs_dir (GeditFindInFilesPluginFindJob* self,
                                                             GFileInfo* file);
static void gedit_find_in_files_plugin_find_job_execute_data_free (gpointer _data);
static void gedit_find_in_files_plugin_find_job_execute_async_ready_wrapper (GObject *source_object,
                                                                      GAsyncResult *res,
                                                                      void *user_data);
void gedit_find_in_files_plugin_find_job_execute (GeditFindInFilesPluginFindJob* self,
                                                  const gchar* root,
                                                  GAsyncReadyCallback _callback_,
                                                  gpointer _user_data_);
void gedit_find_in_files_plugin_find_job_execute_finish (GeditFindInFilesPluginFindJob* self,
                                                         GAsyncResult* _res_,
                                                         GError** error);
static gboolean gedit_find_in_files_plugin_find_job_execute_co (GeditFindInFilesPluginFindJobExecuteData* _data_);
static void gedit_find_in_files_plugin_find_job_execute_ready (GObject* source_object,
                                                        GAsyncResult* _res_,
                                                        gpointer _user_data_);
static void _g_object_unref0_ (gpointer var);
static inline void _g_queue_free__g_object_unref0_ (GQueue* self);
static inline void _g_list_free__g_object_unref0_ (GList* self);
static void gedit_find_in_files_plugin_find_job_get_line (GeditFindInFilesPluginFindJob* self,
                                                   guint8* buffer,
                                                   gsize buffer_size,
                                                   GeditFindInFilesPluginRange* span,
                                                   GeditFindInFilesPluginBookmark* bookmark);
static gboolean gedit_find_in_files_plugin_find_job_is_word_boundary (GeditFindInFilesPluginFindJob* self,
                                                               guint8* buf,
                                                               gsize buf_size,
                                                               gsize from,
                                                               gsize to);
const gchar* gedit_find_in_files_plugin_find_job_get_needle (GeditFindInFilesPluginFindJob* self);
static void gedit_find_in_files_plugin_find_job_finalize (GeditFindInFilesPluginFindJob * obj);

const GeditFindInFilesPluginBookmark GEDIT_FIND_IN_FILES_PLUGIN_BOOKMARK_EmptyBookmark = {0, (gsize) 0};

gboolean
gedit_find_in_files_plugin_imatcher_has_match (GeditFindInFilesPluginIMatcher* self,
                                               guint8* text,
                                               gsize text_length,
                                               gsize pos,
                                               GeditFindInFilesPluginRange* match)
{
	g_return_val_if_fail (self != NULL, FALSE);
	return GEDIT_FIND_IN_FILES_PLUGIN_IMATCHER_GET_INTERFACE (self)->has_match (self, text, text_length, pos, match);
}


static void
gedit_find_in_files_plugin_imatcher_base_init (GeditFindInFilesPluginIMatcherIface * iface)
{
	static gboolean initialized = FALSE;
	if (!initialized) {
		initialized = TRUE;
	}
}


GType
gedit_find_in_files_plugin_imatcher_get_type (void)
{
	return gedit_find_in_files_plugin_imatcher_type_id;
}


GType
gedit_find_in_files_plugin_imatcher_register_type (GTypeModule * module)
{
	static const GTypeInfo g_define_type_info = { sizeof (GeditFindInFilesPluginIMatcherIface), (GBaseInitFunc) gedit_find_in_files_plugin_imatcher_base_init, (GBaseFinalizeFunc) NULL, (GClassInitFunc) NULL, (GClassFinalizeFunc) NULL, NULL, 0, 0, (GInstanceInitFunc) NULL, NULL };
	gedit_find_in_files_plugin_imatcher_type_id = g_type_module_register_type (module, G_TYPE_INTERFACE, "GeditFindInFilesPluginIMatcher", &g_define_type_info, 0);
	g_type_interface_add_prerequisite (gedit_find_in_files_plugin_imatcher_type_id, G_TYPE_OBJECT);
	return gedit_find_in_files_plugin_imatcher_type_id;
}


GeditFindInFilesPluginRange*
gedit_find_in_files_plugin_range_dup (const GeditFindInFilesPluginRange* self)
{
	GeditFindInFilesPluginRange* dup;
	dup = g_new0 (GeditFindInFilesPluginRange, 1);
	memcpy (dup, self, sizeof (GeditFindInFilesPluginRange));
	return dup;
}


void
gedit_find_in_files_plugin_range_free (GeditFindInFilesPluginRange* self)
{
	g_free (self);
}


GType
gedit_find_in_files_plugin_range_get_type (void)
{
	static volatile gsize gedit_find_in_files_plugin_range_type_id__volatile = 0;
	if (g_once_init_enter (&gedit_find_in_files_plugin_range_type_id__volatile)) {
		GType gedit_find_in_files_plugin_range_type_id;
		gedit_find_in_files_plugin_range_type_id = g_boxed_type_register_static ("GeditFindInFilesPluginRange", (GBoxedCopyFunc) gedit_find_in_files_plugin_range_dup, (GBoxedFreeFunc) gedit_find_in_files_plugin_range_free);
		g_once_init_leave (&gedit_find_in_files_plugin_range_type_id__volatile, gedit_find_in_files_plugin_range_type_id);
	}
	return gedit_find_in_files_plugin_range_type_id__volatile;
}


GeditFindInFilesPluginBookmark*
gedit_find_in_files_plugin_bookmark_dup (const GeditFindInFilesPluginBookmark* self)
{
	GeditFindInFilesPluginBookmark* dup;
	dup = g_new0 (GeditFindInFilesPluginBookmark, 1);
	memcpy (dup, self, sizeof (GeditFindInFilesPluginBookmark));
	return dup;
}


void
gedit_find_in_files_plugin_bookmark_free (GeditFindInFilesPluginBookmark* self)
{
	g_free (self);
}


GType
gedit_find_in_files_plugin_bookmark_get_type (void)
{
	static volatile gsize gedit_find_in_files_plugin_bookmark_type_id__volatile = 0;
	if (g_once_init_enter (&gedit_find_in_files_plugin_bookmark_type_id__volatile)) {
		GType gedit_find_in_files_plugin_bookmark_type_id;
		gedit_find_in_files_plugin_bookmark_type_id = g_boxed_type_register_static ("GeditFindInFilesPluginBookmark", (GBoxedCopyFunc) gedit_find_in_files_plugin_bookmark_dup, (GBoxedFreeFunc) gedit_find_in_files_plugin_bookmark_free);
		g_once_init_leave (&gedit_find_in_files_plugin_bookmark_type_id__volatile, gedit_find_in_files_plugin_bookmark_type_id);
	}
	return gedit_find_in_files_plugin_bookmark_type_id__volatile;
}


void
gedit_find_in_files_plugin_result_copy (const GeditFindInFilesPluginResult* self,
                                        GeditFindInFilesPluginResult* dest)
{
	const gchar* _tmp0_;
	gchar* _tmp1_;
	gsize _tmp2_;
	const gchar* _tmp3_;
	gchar* _tmp4_;
	_tmp0_ = (*self).path;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 ((*dest).path);
	(*dest).path = _tmp1_;
	_tmp2_ = (*self).line;
	(*dest).line = _tmp2_;
	_tmp3_ = (*self).context;
	_tmp4_ = g_strdup (_tmp3_);
	_g_free0 ((*dest).context);
	(*dest).context = _tmp4_;
}


void
gedit_find_in_files_plugin_result_destroy (GeditFindInFilesPluginResult* self)
{
	_g_free0 ((*self).path);
	_g_free0 ((*self).context);
}


GeditFindInFilesPluginResult*
gedit_find_in_files_plugin_result_dup (const GeditFindInFilesPluginResult* self)
{
	GeditFindInFilesPluginResult* dup;
	dup = g_new0 (GeditFindInFilesPluginResult, 1);
	gedit_find_in_files_plugin_result_copy (self, dup);
	return dup;
}


void
gedit_find_in_files_plugin_result_free (GeditFindInFilesPluginResult* self)
{
	gedit_find_in_files_plugin_result_destroy (self);
	g_free (self);
}


GType
gedit_find_in_files_plugin_result_get_type (void)
{
	static volatile gsize gedit_find_in_files_plugin_result_type_id__volatile = 0;
	if (g_once_init_enter (&gedit_find_in_files_plugin_result_type_id__volatile)) {
		GType gedit_find_in_files_plugin_result_type_id;
		gedit_find_in_files_plugin_result_type_id = g_boxed_type_register_static ("GeditFindInFilesPluginResult", (GBoxedCopyFunc) gedit_find_in_files_plugin_result_dup, (GBoxedFreeFunc) gedit_find_in_files_plugin_result_free);
		g_once_init_leave (&gedit_find_in_files_plugin_result_type_id__volatile, gedit_find_in_files_plugin_result_type_id);
	}
	return gedit_find_in_files_plugin_result_type_id__volatile;
}


static void
_g_free0_ (gpointer var)
{
	var = (g_free (var), NULL);
}


static void
_g_thread_unref0_ (gpointer var)
{
	(var == NULL) ? NULL : (var = (g_thread_unref (var), NULL));
}


static inline void
_g_list_free__g_thread_unref0_ (GList* self)
{
	g_list_free_full (self, (GDestroyNotify) _g_thread_unref0_);
}


static gboolean
_____lambda5_ (GeditFindInFilesPluginFindJob* self)
{
	gboolean result = FALSE;
	g_signal_emit (self, gedit_find_in_files_plugin_find_job_signals[GEDIT_FIND_IN_FILES_PLUGIN_FIND_JOB_ON_SEARCH_FINISHED_SIGNAL], 0);
	result = FALSE;
	return result;
}


static gboolean
______lambda5__gsource_func (gpointer self)
{
	gboolean result;
	result = _____lambda5_ ((GeditFindInFilesPluginFindJob*) self);
	return result;
}


static gint
gedit_find_in_files_plugin_find_job_worker (GeditFindInFilesPluginFindJob* self)
{
	gint result = 0;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, 0);
	while (TRUE) {
		GTimeVal tv = {0};
		gchar* path = NULL;
		GAsyncQueue* _tmp0_;
		gpointer _tmp1_;
		GCancellable* _tmp2_;
		const gchar* _tmp3_;
		const gchar* _tmp4_;
		g_get_current_time (&tv);
		g_time_val_add (&tv, (glong) (1000000 / 2));
		_tmp0_ = self->priv->scan_queue;
		_tmp1_ = g_async_queue_timed_pop (_tmp0_, &tv);
		path = (gchar*) _tmp1_;
		_tmp2_ = self->priv->cancellable;
		if (g_cancellable_is_cancelled (_tmp2_)) {
			_g_free0 (path);
			break;
		}
		_tmp3_ = path;
		if (_tmp3_ == NULL) {
			_g_free0 (path);
			break;
		}
		_tmp4_ = path;
		gedit_find_in_files_plugin_find_job_scan_file (self, _tmp4_);
		_g_free0 (path);
	}
	{
		guint _tmp5_;
		_tmp5_ = self->priv->running_workers;
		g_rec_mutex_lock (&self->priv->__lock_running_workers);
		{
			guint _tmp6_;
			guint _tmp7_;
			_tmp6_ = self->priv->running_workers;
			self->priv->running_workers = _tmp6_ - 1;
			_tmp7_ = self->priv->running_workers;
			if (((guint) 0) == _tmp7_) {
				g_idle_add_full (G_PRIORITY_DEFAULT_IDLE, ______lambda5__gsource_func, gedit_find_in_files_plugin_find_job_ref (self), gedit_find_in_files_plugin_find_job_unref);
			}
		}
		__finally1:
		{
			guint _tmp8_;
			_tmp8_ = self->priv->running_workers;
			g_rec_mutex_unlock (&self->priv->__lock_running_workers);
		}
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			gint _tmp9_ = 0;
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return _tmp9_;
		}
	}
	result = 0;
	return result;
}


static gpointer
_g_object_ref0 (gpointer self)
{
	return self ? g_object_ref (self) : NULL;
}


GeditFindInFilesPluginFindJob*
gedit_find_in_files_plugin_find_job_construct (GType object_type,
                                               GCancellable* cancellable)
{
	GeditFindInFilesPluginFindJob* self = NULL;
	GCancellable* _tmp0_ = NULL;
	GCancellable* _tmp1_;
	GCancellable* _tmp3_;
	self = (GeditFindInFilesPluginFindJob*) g_type_create_instance (object_type);
	_tmp1_ = _g_object_ref0 (cancellable);
	_tmp0_ = _tmp1_;
	if (_tmp0_ == NULL) {
		GCancellable* _tmp2_;
		_tmp2_ = g_cancellable_new ();
		_g_object_unref0 (_tmp0_);
		_tmp0_ = _tmp2_;
	}
	_tmp3_ = _tmp0_;
	_tmp0_ = NULL;
	_g_object_unref0 (self->priv->cancellable);
	self->priv->cancellable = _tmp3_;
	gedit_find_in_files_plugin_find_job_set_needle (self, NULL);
	self->include_hidden = FALSE;
	self->match_whole_word = FALSE;
	self->ignore_case = FALSE;
	_g_object_unref0 (_tmp0_);
	return self;
}


GeditFindInFilesPluginFindJob*
gedit_find_in_files_plugin_find_job_new (GCancellable* cancellable)
{
	return gedit_find_in_files_plugin_find_job_construct (GEDIT_FIND_IN_FILES_PLUGIN_TYPE_FIND_JOB, cancellable);
}


void
gedit_find_in_files_plugin_find_job_prepare (GeditFindInFilesPluginFindJob* self,
                                             const gchar* needle,
                                             gboolean is_regex,
                                             GError** error)
{
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (needle != NULL);
	if (is_regex) {
		GeditFindInFilesPluginRegexFind* _tmp0_ = NULL;
		gboolean _tmp1_;
		GeditFindInFilesPluginRegexFind* _tmp2_;
		GeditFindInFilesPluginRegexFind* _tmp3_;
		_tmp1_ = self->ignore_case;
		_tmp2_ = gedit_find_in_files_plugin_regex_find_new (needle, _tmp1_, &_inner_error_);
		_tmp0_ = _tmp2_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			g_propagate_error (error, _inner_error_);
			return;
		}
		_tmp3_ = _tmp0_;
		_tmp0_ = NULL;
		_g_object_unref0 (self->priv->matcher);
		self->priv->matcher = (GeditFindInFilesPluginIMatcher*) _tmp3_;
		_g_object_unref0 (_tmp0_);
	} else {
		gboolean _tmp4_;
		GeditFindInFilesPluginBoyerMooreHorspool* _tmp5_;
		_tmp4_ = self->ignore_case;
		_tmp5_ = gedit_find_in_files_plugin_boyer_moore_horspool_new (needle, _tmp4_);
		_g_object_unref0 (self->priv->matcher);
		self->priv->matcher = (GeditFindInFilesPluginIMatcher*) _tmp5_;
	}
}


static gpointer
_gedit_find_in_files_plugin_find_job_worker_gthread_func (gpointer self)
{
	gpointer result;
	result = (gpointer) ((gintptr) gedit_find_in_files_plugin_find_job_worker ((GeditFindInFilesPluginFindJob*) self));
	gedit_find_in_files_plugin_find_job_unref (self);
	return result;
}


static void
gedit_find_in_files_plugin_find_job_start_workers_pool (GeditFindInFilesPluginFindJob* self)
{
	guint _tmp0_;
	guint online_cpus = 0U;
	guint _tmp9_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->running_workers;
	if (_tmp0_ != ((guint) 0)) {
		return;
	}
	online_cpus = g_get_num_processors ();
	{
		gint i = 0;
		i = 0;
		{
			gboolean _tmp1_ = FALSE;
			_tmp1_ = TRUE;
			while (TRUE) {
				gint _tmp3_;
				guint _tmp4_;
				gint _tmp5_;
				gchar* _tmp6_;
				gchar* _tmp7_;
				GThread* _tmp8_;
				if (!_tmp1_) {
					gint _tmp2_;
					_tmp2_ = i;
					i = _tmp2_ + 1;
				}
				_tmp1_ = FALSE;
				_tmp3_ = i;
				_tmp4_ = online_cpus;
				if (!(((guint) _tmp3_) < _tmp4_)) {
					break;
				}
				_tmp5_ = i;
				_tmp6_ = g_strdup_printf ("Worker %d", _tmp5_);
				_tmp7_ = _tmp6_;
				_tmp8_ = g_thread_new (_tmp7_, _gedit_find_in_files_plugin_find_job_worker_gthread_func, gedit_find_in_files_plugin_find_job_ref (self));
				self->priv->thread_workers = g_list_append (self->priv->thread_workers, _tmp8_);
				_g_free0 (_tmp7_);
			}
		}
	}
	_tmp9_ = online_cpus;
	self->priv->running_workers = _tmp9_;
}


gchar*
gedit_find_in_files_plugin_find_job_extract_context (GeditFindInFilesPluginFindJob* self,
                                                     guint8* buffer,
                                                     GeditFindInFilesPluginRange* range)
{
	gchar* result = NULL;
	guint8* slice = NULL;
	GeditFindInFilesPluginRange _tmp0_;
	gsize _tmp1_;
	GeditFindInFilesPluginRange _tmp2_;
	gsize _tmp3_;
	guint8* _tmp4_;
	GeditFindInFilesPluginRange _tmp5_;
	gsize _tmp6_;
	GeditFindInFilesPluginRange _tmp7_;
	gsize _tmp8_;
	GeditFindInFilesPluginRange _tmp9_;
	gsize _tmp10_;
	gchar* _tmp11_;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (range != NULL, NULL);
	_tmp0_ = *range;
	_tmp1_ = _tmp0_.to;
	_tmp2_ = *range;
	_tmp3_ = _tmp2_.from;
	_tmp4_ = g_new0 (guint8, _tmp1_ - _tmp3_);
	slice = _tmp4_;
	_tmp5_ = *range;
	_tmp6_ = _tmp5_.from;
	_tmp7_ = *range;
	_tmp8_ = _tmp7_.to;
	_tmp9_ = *range;
	_tmp10_ = _tmp9_.from;
	memcpy (slice, buffer + _tmp6_, _tmp8_ - _tmp10_);
	_tmp11_ = gedit_utils_make_valid_utf8 ((const gchar*) slice);
	result = _tmp11_;
	return result;
}


static gpointer
_g_thread_ref0 (gpointer self)
{
	return self ? g_thread_ref (self) : NULL;
}


void
gedit_find_in_files_plugin_find_job_halt (GeditFindInFilesPluginFindJob* self)
{
	guint _tmp0_;
	GCancellable* _tmp1_;
	GList* _tmp2_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->running_workers;
	if (_tmp0_ == ((guint) 0)) {
		return;
	}
	_tmp1_ = self->priv->cancellable;
	g_cancellable_cancel (_tmp1_);
	_tmp2_ = self->priv->thread_workers;
	{
		GList* worker_collection = NULL;
		GList* worker_it = NULL;
		worker_collection = _tmp2_;
		for (worker_it = worker_collection; worker_it != NULL; worker_it = worker_it->next) {
			GThread* _tmp3_;
			GThread* worker = NULL;
			_tmp3_ = _g_thread_ref0 ((GThread*) worker_it->data);
			worker = _tmp3_;
			{
				GThread* _tmp4_;
				GThread* _tmp5_;
				_tmp4_ = worker;
				_tmp5_ = _g_thread_ref0 (_tmp4_);
				g_thread_join (_tmp5_);
				_g_thread_unref0 (worker);
			}
		}
	}
}


static gboolean
gedit_find_in_files_plugin_find_job_is_binary (GeditFindInFilesPluginFindJob* self,
                                               guint8* buffer,
                                               gsize buffer_size)
{
	gboolean result = FALSE;
	void* _tmp0_;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = memchr (buffer, (gint) '\0', buffer_size);
	result = _tmp0_ != NULL;
	return result;
}


static gboolean
gedit_find_in_files_plugin_find_job_ignore_vcs_dir (GeditFindInFilesPluginFindJob* self,
                                                    GFileInfo* file)
{
	gboolean result = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (file != NULL, FALSE);
	if (g_file_info_get_file_type (file) == G_FILE_TYPE_DIRECTORY) {
		gchar* name = NULL;
		const gchar* _tmp0_;
		gchar* _tmp1_;
		gboolean _tmp2_ = FALSE;
		gboolean _tmp3_ = FALSE;
		gboolean _tmp4_ = FALSE;
		gboolean _tmp5_ = FALSE;
		const gchar* _tmp6_;
		_tmp0_ = g_file_info_get_name (file);
		_tmp1_ = g_strdup (_tmp0_);
		name = _tmp1_;
		_tmp6_ = name;
		if (g_strcmp0 (_tmp6_, ".git") == 0) {
			_tmp5_ = TRUE;
		} else {
			const gchar* _tmp7_;
			_tmp7_ = name;
			_tmp5_ = g_strcmp0 (_tmp7_, ".bzr") == 0;
		}
		if (_tmp5_) {
			_tmp4_ = TRUE;
		} else {
			const gchar* _tmp8_;
			_tmp8_ = name;
			_tmp4_ = g_strcmp0 (_tmp8_, ".svn") == 0;
		}
		if (_tmp4_) {
			_tmp3_ = TRUE;
		} else {
			const gchar* _tmp9_;
			_tmp9_ = name;
			_tmp3_ = g_strcmp0 (_tmp9_, ".hg") == 0;
		}
		if (_tmp3_) {
			_tmp2_ = TRUE;
		} else {
			const gchar* _tmp10_;
			_tmp10_ = name;
			_tmp2_ = g_strcmp0 (_tmp10_, "_darcs") == 0;
		}
		if (_tmp2_) {
			result = TRUE;
			_g_free0 (name);
			return result;
		}
		_g_free0 (name);
	}
	result = FALSE;
	return result;
}


static void
gedit_find_in_files_plugin_find_job_execute_data_free (gpointer _data)
{
	GeditFindInFilesPluginFindJobExecuteData* _data_;
	_data_ = _data;
	_g_free0 (_data_->root);
	_gedit_find_in_files_plugin_find_job_unref0 (_data_->self);
	g_slice_free (GeditFindInFilesPluginFindJobExecuteData, _data_);
}


static void
gedit_find_in_files_plugin_find_job_execute_async_ready_wrapper (GObject *source_object,
                                                                 GAsyncResult *res,
                                                                 void *user_data)
{
	GeditFindInFilesPluginFindJobExecuteData* _task_data_;
	_task_data_ = g_task_get_task_data (G_TASK (res));
	if (_task_data_->_callback_ != NULL) {
		_task_data_->_callback_ (source_object, res, user_data);
	}
	_task_data_->_task_complete_ = TRUE;
}


static gpointer
_gedit_find_in_files_plugin_find_job_ref0 (gpointer self)
{
	return self ? gedit_find_in_files_plugin_find_job_ref (self) : NULL;
}


void
gedit_find_in_files_plugin_find_job_execute (GeditFindInFilesPluginFindJob* self,
                                             const gchar* root,
                                             GAsyncReadyCallback _callback_,
                                             gpointer _user_data_)
{
	GeditFindInFilesPluginFindJobExecuteData* _data_;
	GeditFindInFilesPluginFindJob* _tmp0_;
	gchar* _tmp1_;
	_data_ = g_slice_new0 (GeditFindInFilesPluginFindJobExecuteData);
	_data_->_callback_ = _callback_;
	_data_->_async_result = g_task_new (NULL, NULL, gedit_find_in_files_plugin_find_job_execute_async_ready_wrapper, _user_data_);
	if (_callback_ == NULL) {
		_data_->_task_complete_ = TRUE;
	}
	g_task_set_task_data (_data_->_async_result, _data_, gedit_find_in_files_plugin_find_job_execute_data_free);
	_tmp0_ = _gedit_find_in_files_plugin_find_job_ref0 (self);
	_data_->self = _tmp0_;
	_tmp1_ = g_strdup (root);
	_g_free0 (_data_->root);
	_data_->root = _tmp1_;
	gedit_find_in_files_plugin_find_job_execute_co (_data_);
}


void
gedit_find_in_files_plugin_find_job_execute_finish (GeditFindInFilesPluginFindJob* self,
                                                    GAsyncResult* _res_,
                                                    GError** error)
{
	GeditFindInFilesPluginFindJobExecuteData* _data_;
	_data_ = g_task_propagate_pointer (G_TASK (_res_), error);
	if (NULL == _data_) {
		return;
	}
}


static void
gedit_find_in_files_plugin_find_job_execute_ready (GObject* source_object,
                                                   GAsyncResult* _res_,
                                                   gpointer _user_data_)
{
	GeditFindInFilesPluginFindJobExecuteData* _data_;
	_data_ = _user_data_;
	_data_->_source_object_ = source_object;
	_data_->_res_ = _res_;
	_data_->_task_complete_ = TRUE;
	gedit_find_in_files_plugin_find_job_execute_co (_data_);
}


static void
_g_object_unref0_ (gpointer var)
{
	(var == NULL) ? NULL : (var = (g_object_unref (var), NULL));
}


static inline void
_g_queue_free__g_object_unref0_ (GQueue* self)
{
	g_queue_free_full (self, (GDestroyNotify) _g_object_unref0_);
}


static inline void
_g_list_free__g_object_unref0_ (GList* self)
{
	g_list_free_full (self, (GDestroyNotify) _g_object_unref0_);
}


static gchar
string_get (const gchar* self,
            glong index)
{
	gchar result = '\0';
	gchar _tmp0_;
	g_return_val_if_fail (self != NULL, '\0');
	_tmp0_ = ((gchar*) self)[index];
	result = _tmp0_;
	return result;
}


static gboolean
gedit_find_in_files_plugin_find_job_execute_co (GeditFindInFilesPluginFindJobExecuteData* _data_)
{
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		case 1:
		goto _state_1;
		case 2:
		goto _state_2;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	_data_->_tmp0_ = g_queue_new ();
	_data_->queue = _data_->_tmp0_;
	_data_->_tmp1_ = g_str_hash;
	_data_->_tmp2_ = g_str_equal;
	_data_->_tmp3_ = g_hash_table_new_full (_data_->_tmp1_, _data_->_tmp2_, _g_free0_, NULL);
	_data_->visited = _data_->_tmp3_;
	gedit_find_in_files_plugin_find_job_start_workers_pool (_data_->self);
	_data_->_tmp4_ = _data_->queue;
	_data_->_tmp5_ = g_file_new_for_path (_data_->root);
	g_queue_push_tail (_data_->_tmp4_, _data_->_tmp5_);
	while (TRUE) {
		_data_->_tmp6_ = _data_->queue;
		if (!(!g_queue_is_empty (_data_->_tmp6_))) {
			break;
		}
		_data_->_tmp7_ = _data_->self->priv->cancellable;
		if (g_cancellable_is_cancelled (_data_->_tmp7_)) {
			break;
		}
		_data_->_tmp8_ = _data_->queue;
		_data_->_tmp9_ = g_queue_pop_head (_data_->_tmp8_);
		_data_->dir = (GFile*) _data_->_tmp9_;
		_data_->_tmp10_ = _data_->dir;
		_data_->_state_ = 1;
		g_file_enumerate_children_async (_data_->_tmp10_, G_FILE_ATTRIBUTE_STANDARD_NAME, G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS, G_PRIORITY_DEFAULT, NULL, gedit_find_in_files_plugin_find_job_execute_ready, _data_);
		return FALSE;
		_state_1:
		_data_->_tmp11_ = g_file_enumerate_children_finish (_data_->_tmp10_, _data_->_res_, &_data_->_inner_error_);
		_data_->e = _data_->_tmp11_;
		if (G_UNLIKELY (_data_->_inner_error_ != NULL)) {
			g_task_return_error (_data_->_async_result, _data_->_inner_error_);
			_g_object_unref0 (_data_->dir);
			_g_hash_table_unref0 (_data_->visited);
			__g_queue_free__g_object_unref0_0 (_data_->queue);
			g_object_unref (_data_->_async_result);
			return FALSE;
		}
		while (TRUE) {
			_data_->_tmp12_ = _data_->e;
			_data_->_state_ = 2;
			g_file_enumerator_next_files_async (_data_->_tmp12_, 100, G_PRIORITY_DEFAULT, NULL, gedit_find_in_files_plugin_find_job_execute_ready, _data_);
			return FALSE;
			_state_2:
			_data_->_tmp13_ = g_file_enumerator_next_files_finish (_data_->_tmp12_, _data_->_res_, &_data_->_inner_error_);
			_data_->files = _data_->_tmp13_;
			if (G_UNLIKELY (_data_->_inner_error_ != NULL)) {
				g_task_return_error (_data_->_async_result, _data_->_inner_error_);
				_g_object_unref0 (_data_->e);
				_g_object_unref0 (_data_->dir);
				_g_hash_table_unref0 (_data_->visited);
				__g_queue_free__g_object_unref0_0 (_data_->queue);
				g_object_unref (_data_->_async_result);
				return FALSE;
			}
			_data_->_tmp14_ = _data_->files;
			if (_data_->_tmp14_ == NULL) {
				__g_list_free__g_object_unref0_0 (_data_->files);
				break;
			}
			_data_->_tmp15_ = _data_->self->priv->cancellable;
			if (g_cancellable_is_cancelled (_data_->_tmp15_)) {
				__g_list_free__g_object_unref0_0 (_data_->files);
				break;
			}
			_data_->_tmp16_ = _data_->files;
			{
				_data_->file_collection = _data_->_tmp16_;
				for (_data_->file_it = _data_->file_collection; _data_->file_it != NULL; _data_->file_it = _data_->file_it->next) {
					_data_->_tmp17_ = _g_object_ref0 ((GFileInfo*) _data_->file_it->data);
					_data_->file = _data_->_tmp17_;
					{
						_data_->_tmp19_ = _data_->self->include_hidden;
						if (!_data_->_tmp19_) {
							_data_->_tmp20_ = _data_->file;
							_data_->_tmp21_ = g_file_info_get_name (_data_->_tmp20_);
							_data_->_tmp18_ = string_get (_data_->_tmp21_, (glong) 0) == '.';
						} else {
							_data_->_tmp18_ = FALSE;
						}
						if (_data_->_tmp18_) {
							_g_object_unref0 (_data_->file);
							continue;
						}
						_data_->_tmp22_ = _data_->file;
						if (gedit_find_in_files_plugin_find_job_ignore_vcs_dir (_data_->self, _data_->_tmp22_)) {
							_g_object_unref0 (_data_->file);
							continue;
						}
						_data_->_tmp23_ = _data_->dir;
						_data_->_tmp24_ = _data_->file;
						_data_->_tmp25_ = g_file_info_get_name (_data_->_tmp24_);
						_data_->_tmp26_ = g_file_resolve_relative_path (_data_->_tmp23_, _data_->_tmp25_);
						_data_->_file = _data_->_tmp26_;
						_data_->_tmp27_ = _data_->file;
						switch (g_file_info_get_file_type (_data_->_tmp27_)) {
							case G_FILE_TYPE_REGULAR:
							{
								_data_->_tmp28_ = _data_->self->priv->scan_queue;
								_data_->_tmp29_ = _data_->_file;
								_data_->_tmp30_ = g_file_get_path (_data_->_tmp29_);
								g_async_queue_push (_data_->_tmp28_, _data_->_tmp30_);
								break;
							}
							case G_FILE_TYPE_DIRECTORY:
							{
								_data_->_tmp31_ = _data_->queue;
								_data_->_tmp32_ = _data_->_file;
								_data_->_tmp33_ = _g_object_ref0 (_data_->_tmp32_);
								g_queue_push_tail (_data_->_tmp31_, _data_->_tmp33_);
								_data_->_tmp34_ = _data_->visited;
								_data_->_tmp35_ = _data_->_file;
								_data_->_tmp36_ = g_file_get_path (_data_->_tmp35_);
								g_hash_table_insert (_data_->_tmp34_, _data_->_tmp36_, (gpointer) ((gintptr) TRUE));
								break;
							}
							case G_FILE_TYPE_SYMBOLIC_LINK:
							{
								_data_->_tmp37_ = _data_->_file;
								_data_->_tmp38_ = g_file_get_path (_data_->_tmp37_);
								_data_->_tmp39_ = _data_->_tmp38_;
								_data_->_tmp40_ = realpath (_data_->_tmp39_, NULL);
								_data_->_tmp41_ = _data_->_tmp40_;
								_g_free0 (_data_->_tmp39_);
								_data_->link_dest = _data_->_tmp41_;
								_data_->_tmp43_ = _data_->link_dest;
								if (_data_->_tmp43_ != NULL) {
									_data_->_tmp44_ = _data_->visited;
									_data_->_tmp45_ = _data_->link_dest;
									_data_->_tmp42_ = !g_hash_table_contains (_data_->_tmp44_, _data_->_tmp45_);
								} else {
									_data_->_tmp42_ = FALSE;
								}
								if (_data_->_tmp42_) {
									_data_->_tmp47_ = _data_->link_dest;
									if (g_file_test (_data_->_tmp47_, G_FILE_TEST_IS_DIR)) {
										_data_->_tmp49_ = _data_->self->ignore_case;
										if (!_data_->_tmp49_) {
											_data_->_tmp50_ = _data_->link_dest;
											_data_->_tmp48_ = string_get (_data_->_tmp50_, (glong) 0) != '.';
										} else {
											_data_->_tmp48_ = FALSE;
										}
										_data_->_tmp46_ = _data_->_tmp48_;
									} else {
										_data_->_tmp46_ = FALSE;
									}
									if (_data_->_tmp46_) {
										_data_->_tmp51_ = _data_->queue;
										_data_->_tmp52_ = _data_->link_dest;
										_data_->_tmp53_ = g_file_new_for_path (_data_->_tmp52_);
										g_queue_push_tail (_data_->_tmp51_, _data_->_tmp53_);
									}
								}
								_g_free0 (_data_->link_dest);
								break;
							}
							default:
							break;
						}
						_g_object_unref0 (_data_->_file);
						_g_object_unref0 (_data_->file);
					}
				}
			}
			__g_list_free__g_object_unref0_0 (_data_->files);
		}
		_g_object_unref0 (_data_->e);
		_g_object_unref0 (_data_->dir);
	}
	_g_hash_table_unref0 (_data_->visited);
	__g_queue_free__g_object_unref0_0 (_data_->queue);
	g_task_return_pointer (_data_->_async_result, _data_, NULL);
	if (_data_->_state_ != 0) {
		while (_data_->_task_complete_ != TRUE) {
			g_main_context_iteration (g_task_get_context (_data_->_async_result), TRUE);
		}
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}


static void
gedit_find_in_files_plugin_find_job_get_line (GeditFindInFilesPluginFindJob* self,
                                              guint8* buffer,
                                              gsize buffer_size,
                                              GeditFindInFilesPluginRange* span,
                                              GeditFindInFilesPluginBookmark* bookmark)
{
	gint line_count = 0;
	GeditFindInFilesPluginBookmark _tmp0_;
	gint _tmp1_;
	gsize line_start = 0UL;
	GeditFindInFilesPluginBookmark _tmp2_;
	gsize _tmp3_;
	guint8* ptr = NULL;
	GeditFindInFilesPluginBookmark _tmp4_;
	gsize _tmp5_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (span != NULL);
	g_return_if_fail (bookmark != NULL);
	_tmp0_ = *bookmark;
	_tmp1_ = _tmp0_.line_number;
	line_count = _tmp1_;
	_tmp2_ = *bookmark;
	_tmp3_ = _tmp2_.line_start;
	line_start = _tmp3_;
	_tmp4_ = *bookmark;
	_tmp5_ = _tmp4_.line_start;
	ptr = buffer + _tmp5_;
	while (TRUE) {
		guint8* _tmp6_;
		guint8* nl = NULL;
		guint8* _tmp7_;
		guint8* _tmp8_;
		void* _tmp9_;
		guint8* _tmp10_;
		gsize line_length = 0UL;
		guint8* _tmp12_;
		guint8* _tmp13_;
		gboolean _tmp14_ = FALSE;
		GeditFindInFilesPluginRange _tmp15_;
		gsize _tmp16_;
		gsize _tmp17_;
		gint _tmp25_;
		gsize _tmp26_;
		gsize _tmp27_;
		guint8* _tmp28_;
		_tmp6_ = ptr;
		if (!(_tmp6_ < (buffer + buffer_size))) {
			break;
		}
		_tmp7_ = ptr;
		_tmp8_ = ptr;
		_tmp9_ = memchr (_tmp7_, (gint) '\n', buffer_size - (_tmp8_ - buffer));
		nl = _tmp9_;
		_tmp10_ = nl;
		if (_tmp10_ == NULL) {
			nl = (buffer + buffer_size) + 1;
		} else {
			guint8* _tmp11_;
			_tmp11_ = nl;
			nl = _tmp11_ + 1;
		}
		_tmp12_ = nl;
		_tmp13_ = ptr;
		line_length = _tmp12_ - _tmp13_;
		_tmp15_ = *span;
		_tmp16_ = _tmp15_.from;
		_tmp17_ = line_start;
		if (_tmp16_ >= _tmp17_) {
			GeditFindInFilesPluginRange _tmp18_;
			gsize _tmp19_;
			gsize _tmp20_;
			gsize _tmp21_;
			_tmp18_ = *span;
			_tmp19_ = _tmp18_.to;
			_tmp20_ = line_start;
			_tmp21_ = line_length;
			_tmp14_ = _tmp19_ < (_tmp20_ + _tmp21_);
		} else {
			_tmp14_ = FALSE;
		}
		if (_tmp14_) {
			gint _tmp22_;
			gsize _tmp23_;
			gsize _tmp24_;
			_tmp22_ = line_count;
			(*bookmark).line_number = _tmp22_;
			_tmp23_ = line_start;
			(*bookmark).line_start = _tmp23_;
			_tmp24_ = line_length;
			(*bookmark).line_length = _tmp24_ - 1;
			return;
		}
		_tmp25_ = line_count;
		line_count = _tmp25_ + 1;
		_tmp26_ = line_start;
		_tmp27_ = line_length;
		line_start = _tmp26_ + _tmp27_;
		_tmp28_ = nl;
		ptr = _tmp28_;
	}
	g_assert_not_reached ();
}


static gunichar
string_get_char (const gchar* self,
                 glong index)
{
	gunichar result = 0U;
	g_return_val_if_fail (self != NULL, 0U);
	result = g_utf8_get_char (((gchar*) self) + index);
	return result;
}


static gboolean
string_get_prev_char (const gchar* self,
                      gint* index,
                      gunichar* c)
{
	gunichar _vala_c = 0U;
	gboolean result = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	if (0 < (*index)) {
		gchar* _tmp0_;
		_tmp0_ = g_utf8_prev_char (((gchar*) self) + (*index));
		*index = (gint) (_tmp0_ - ((gchar*) self));
		_vala_c = g_utf8_get_char (((gchar*) self) + (*index));
		result = TRUE;
		if (c) {
			*c = _vala_c;
		}
		return result;
	} else {
		_vala_c = (gunichar) 0;
		result = FALSE;
		if (c) {
			*c = _vala_c;
		}
		return result;
	}
	if (c) {
		*c = _vala_c;
	}
}


static gboolean
string_get_next_char (const gchar* self,
                      gint* index,
                      gunichar* c)
{
	gunichar _vala_c = 0U;
	gboolean result = FALSE;
	gunichar _tmp0_;
	g_return_val_if_fail (self != NULL, FALSE);
	_vala_c = g_utf8_get_char (((gchar*) self) + (*index));
	_tmp0_ = _vala_c;
	if (_tmp0_ != ((gunichar) 0)) {
		gchar* _tmp1_;
		_tmp1_ = g_utf8_next_char (((gchar*) self) + (*index));
		*index = (gint) (_tmp1_ - ((gchar*) self));
		result = TRUE;
		if (c) {
			*c = _vala_c;
		}
		return result;
	} else {
		result = FALSE;
		if (c) {
			*c = _vala_c;
		}
		return result;
	}
	if (c) {
		*c = _vala_c;
	}
}


static gboolean
gedit_find_in_files_plugin_find_job_is_word_boundary (GeditFindInFilesPluginFindJob* self,
                                                      guint8* buf,
                                                      gsize buf_size,
                                                      gsize from,
                                                      gsize to)
{
	gboolean result = FALSE;
	gunichar ch = 0U;
	gboolean prev = FALSE;
	gboolean next = FALSE;
	const gchar* str = NULL;
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_;
	gint start = 0;
	gint end = 0;
	gunichar head = 0U;
	const gchar* _tmp2_;
	gboolean _tmp3_ = FALSE;
	gint _tmp4_;
	gunichar tail = 0U;
	const gchar* _tmp10_;
	gint _tmp11_;
	gboolean _tmp12_ = FALSE;
	gint _tmp13_;
	gboolean _tmp19_ = FALSE;
	gboolean _tmp20_;
	g_return_val_if_fail (self != NULL, FALSE);
	if (to > from) {
		_tmp0_ = to <= buf_size;
	} else {
		_tmp0_ = FALSE;
	}
	_vala_assert (_tmp0_, "to > from && to <= buf_size");
	if ((to - from) > ((gsize) G_MAXINT)) {
		result = FALSE;
		return result;
	}
	ch = (gunichar) '\0';
	next = TRUE;
	_tmp1_ = next;
	prev = _tmp1_;
	str = (const gchar*) (buf + from);
	start = 0;
	end = (gint) (to - from);
	_tmp2_ = str;
	head = string_get_char (_tmp2_, (glong) 0);
	_tmp4_ = start;
	if (_tmp4_ > 0) {
		const gchar* _tmp5_;
		gunichar _tmp6_ = 0U;
		gboolean _tmp7_;
		_tmp5_ = str;
		_tmp7_ = string_get_prev_char (_tmp5_, &start, &_tmp6_);
		ch = _tmp6_;
		_tmp3_ = _tmp7_;
	} else {
		_tmp3_ = FALSE;
	}
	if (_tmp3_) {
		gunichar _tmp8_;
		gunichar _tmp9_;
		_tmp8_ = head;
		_tmp9_ = ch;
		prev = g_unichar_isalnum (_tmp8_) != g_unichar_isalnum (_tmp9_);
	}
	_tmp10_ = str;
	_tmp11_ = end;
	tail = string_get_char (_tmp10_, (glong) (_tmp11_ - 1));
	_tmp13_ = end;
	if (((gsize) _tmp13_) < buf_size) {
		const gchar* _tmp14_;
		gunichar _tmp15_ = 0U;
		gboolean _tmp16_;
		_tmp14_ = str;
		_tmp16_ = string_get_next_char (_tmp14_, &end, &_tmp15_);
		ch = _tmp15_;
		_tmp12_ = _tmp16_;
	} else {
		_tmp12_ = FALSE;
	}
	if (_tmp12_) {
		gunichar _tmp17_;
		gunichar _tmp18_;
		_tmp17_ = tail;
		_tmp18_ = ch;
		next = g_unichar_isalnum (_tmp17_) != g_unichar_isalnum (_tmp18_);
	}
	_tmp20_ = prev;
	if (_tmp20_) {
		gboolean _tmp21_;
		_tmp21_ = next;
		_tmp19_ = _tmp21_;
	} else {
		_tmp19_ = FALSE;
	}
	result = _tmp19_;
	return result;
}


static void
gedit_find_in_files_plugin_find_job_scan_file (GeditFindInFilesPluginFindJob* self,
                                               const gchar* path)
{
	GMappedFile* file = NULL;
	gsize buffer_size = 0UL;
	GMappedFile* _tmp5_;
	guint8* buffer = NULL;
	GMappedFile* _tmp6_;
	gchar* _tmp7_;
	guint8* _tmp8_;
	gsize _tmp9_;
	GeditFindInFilesPluginRange match = {0};
	GeditFindInFilesPluginRange _tmp10_ = {0};
	GeditFindInFilesPluginBookmark bookmark = {0};
	gint last_line = 0;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (path != NULL);
	{
		GMappedFile* _tmp0_ = NULL;
		GMappedFile* _tmp1_;
		GMappedFile* _tmp2_;
		_tmp1_ = g_mapped_file_new (path, FALSE, &_inner_error_);
		_tmp0_ = _tmp1_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			if (_inner_error_->domain == G_FILE_ERROR) {
				goto __catch2_g_file_error;
			}
			_g_mapped_file_unref0 (file);
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
		_tmp2_ = _tmp0_;
		_tmp0_ = NULL;
		_g_mapped_file_unref0 (file);
		file = _tmp2_;
		_g_mapped_file_unref0 (_tmp0_);
	}
	goto __finally2;
	__catch2_g_file_error:
	{
		GError* err = NULL;
		GError* _tmp3_;
		const gchar* _tmp4_;
		err = _inner_error_;
		_inner_error_ = NULL;
		_tmp3_ = err;
		_tmp4_ = _tmp3_->message;
		g_warning ("job.vala:314: %s", _tmp4_);
		_g_error_free0 (err);
		_g_mapped_file_unref0 (file);
		return;
	}
	__finally2:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		_g_mapped_file_unref0 (file);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	_tmp5_ = file;
	buffer_size = g_mapped_file_get_length (_tmp5_);
	_tmp6_ = file;
	_tmp7_ = g_mapped_file_get_contents (_tmp6_);
	buffer = (guint8*) _tmp7_;
	_tmp8_ = buffer;
	_tmp9_ = buffer_size;
	if (gedit_find_in_files_plugin_find_job_is_binary (self, _tmp8_, _tmp9_)) {
		_g_mapped_file_unref0 (file);
		return;
	}
	_tmp10_.from = (gsize) 0;
	_tmp10_.to = (gsize) 0;
	match = _tmp10_;
	bookmark = GEDIT_FIND_IN_FILES_PLUGIN_BOOKMARK_EmptyBookmark;
	last_line = -1;
	{
		gsize buffer_pos = 0UL;
		buffer_pos = (gsize) 0;
		{
			gboolean _tmp11_ = FALSE;
			_tmp11_ = TRUE;
			while (TRUE) {
				gsize _tmp12_;
				gsize _tmp13_;
				GCancellable* _tmp14_;
				GeditFindInFilesPluginIMatcher* _tmp15_;
				guint8* _tmp16_;
				gsize _tmp17_;
				gsize _tmp18_;
				gboolean _tmp19_;
				gboolean _tmp20_;
				guint8* _tmp29_;
				gsize _tmp30_;
				gint match_line = 0;
				GeditFindInFilesPluginBookmark _tmp31_;
				gint _tmp32_;
				gint _tmp33_;
				gint _tmp34_;
				gint _tmp42_;
				GeditFindInFilesPluginRange _tmp43_;
				gsize _tmp44_;
				if (!_tmp11_) {
				}
				_tmp11_ = FALSE;
				_tmp12_ = buffer_pos;
				_tmp13_ = buffer_size;
				if (!(_tmp12_ < _tmp13_)) {
					break;
				}
				_tmp14_ = self->priv->cancellable;
				if (g_cancellable_is_cancelled (_tmp14_)) {
					break;
				}
				_tmp15_ = self->priv->matcher;
				_tmp16_ = buffer;
				_tmp17_ = buffer_size;
				_tmp18_ = buffer_pos;
				_tmp19_ = gedit_find_in_files_plugin_imatcher_has_match (_tmp15_, _tmp16_, _tmp17_, _tmp18_, &match);
				if (!_tmp19_) {
					break;
				}
				_tmp20_ = self->match_whole_word;
				if (_tmp20_) {
					guint8* _tmp21_;
					gsize _tmp22_;
					GeditFindInFilesPluginRange _tmp23_;
					gsize _tmp24_;
					GeditFindInFilesPluginRange _tmp25_;
					gsize _tmp26_;
					_tmp21_ = buffer;
					_tmp22_ = buffer_size;
					_tmp23_ = match;
					_tmp24_ = _tmp23_.from;
					_tmp25_ = match;
					_tmp26_ = _tmp25_.to;
					if (!gedit_find_in_files_plugin_find_job_is_word_boundary (self, _tmp21_, _tmp22_, (gsize) ((gint) _tmp24_), (gsize) ((gint) _tmp26_))) {
						GeditFindInFilesPluginRange _tmp27_;
						gsize _tmp28_;
						_tmp27_ = match;
						_tmp28_ = _tmp27_.to;
						buffer_pos = _tmp28_;
						continue;
					}
				}
				_tmp29_ = buffer;
				_tmp30_ = buffer_size;
				gedit_find_in_files_plugin_find_job_get_line (self, _tmp29_, _tmp30_, &match, &bookmark);
				_tmp31_ = bookmark;
				_tmp32_ = _tmp31_.line_number;
				match_line = 1 + _tmp32_;
				_tmp33_ = last_line;
				_tmp34_ = match_line;
				if (_tmp33_ != _tmp34_) {
					GeditFindInFilesPluginResult res = {0};
					gchar* _tmp35_;
					gint _tmp36_;
					guint8* _tmp37_;
					GeditFindInFilesPluginRange _tmp38_;
					gchar* _tmp39_;
					GeditFindInFilesPluginResult _tmp40_ = {0};
					GeditFindInFilesPluginResult _tmp41_;
					_tmp35_ = g_strdup (path);
					_tmp36_ = match_line;
					_tmp37_ = buffer;
					_tmp38_ = match;
					_tmp39_ = gedit_find_in_files_plugin_find_job_extract_context (self, _tmp37_, &_tmp38_);
					_g_free0 (_tmp40_.path);
					_tmp40_.path = _tmp35_;
					_tmp40_.line = (gsize) _tmp36_;
					_g_free0 (_tmp40_.context);
					_tmp40_.context = _tmp39_;
					res = _tmp40_;
					_tmp41_ = res;
					g_signal_emit (self, gedit_find_in_files_plugin_find_job_signals[GEDIT_FIND_IN_FILES_PLUGIN_FIND_JOB_ON_MATCH_FOUND_SIGNAL], 0, &_tmp41_);
					gedit_find_in_files_plugin_result_destroy (&res);
				}
				_tmp42_ = match_line;
				last_line = _tmp42_;
				_tmp43_ = match;
				_tmp44_ = _tmp43_.to;
				buffer_pos = _tmp44_;
			}
		}
	}
	_g_mapped_file_unref0 (file);
}


const gchar*
gedit_find_in_files_plugin_find_job_get_needle (GeditFindInFilesPluginFindJob* self)
{
	const gchar* result;
	const gchar* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_needle;
	result = _tmp0_;
	return result;
}


static void
gedit_find_in_files_plugin_find_job_set_needle (GeditFindInFilesPluginFindJob* self,
                                                const gchar* value)
{
	gchar* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_strdup (value);
	_g_free0 (self->priv->_needle);
	self->priv->_needle = _tmp0_;
}


static void
gedit_find_in_files_plugin_value_find_job_init (GValue* value)
{
	value->data[0].v_pointer = NULL;
}


static void
gedit_find_in_files_plugin_value_find_job_free_value (GValue* value)
{
	if (value->data[0].v_pointer) {
		gedit_find_in_files_plugin_find_job_unref (value->data[0].v_pointer);
	}
}


static void
gedit_find_in_files_plugin_value_find_job_copy_value (const GValue* src_value,
                                                      GValue* dest_value)
{
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = gedit_find_in_files_plugin_find_job_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer
gedit_find_in_files_plugin_value_find_job_peek_pointer (const GValue* value)
{
	return value->data[0].v_pointer;
}


static gchar*
gedit_find_in_files_plugin_value_find_job_collect_value (GValue* value,
                                                         guint n_collect_values,
                                                         GTypeCValue* collect_values,
                                                         guint collect_flags)
{
	if (collect_values[0].v_pointer) {
		GeditFindInFilesPluginFindJob * object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = gedit_find_in_files_plugin_find_job_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar*
gedit_find_in_files_plugin_value_find_job_lcopy_value (const GValue* value,
                                                       guint n_collect_values,
                                                       GTypeCValue* collect_values,
                                                       guint collect_flags)
{
	GeditFindInFilesPluginFindJob ** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = gedit_find_in_files_plugin_find_job_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec*
gedit_find_in_files_plugin_param_spec_find_job (const gchar* name,
                                                const gchar* nick,
                                                const gchar* blurb,
                                                GType object_type,
                                                GParamFlags flags)
{
	GeditFindInFilesPluginParamSpecFindJob* spec;
	g_return_val_if_fail (g_type_is_a (object_type, GEDIT_FIND_IN_FILES_PLUGIN_TYPE_FIND_JOB), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer
gedit_find_in_files_plugin_value_get_find_job (const GValue* value)
{
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, GEDIT_FIND_IN_FILES_PLUGIN_TYPE_FIND_JOB), NULL);
	return value->data[0].v_pointer;
}


void
gedit_find_in_files_plugin_value_set_find_job (GValue* value,
                                               gpointer v_object)
{
	GeditFindInFilesPluginFindJob * old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, GEDIT_FIND_IN_FILES_PLUGIN_TYPE_FIND_JOB));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, GEDIT_FIND_IN_FILES_PLUGIN_TYPE_FIND_JOB));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		gedit_find_in_files_plugin_find_job_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		gedit_find_in_files_plugin_find_job_unref (old);
	}
}


void
gedit_find_in_files_plugin_value_take_find_job (GValue* value,
                                                gpointer v_object)
{
	GeditFindInFilesPluginFindJob * old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, GEDIT_FIND_IN_FILES_PLUGIN_TYPE_FIND_JOB));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, GEDIT_FIND_IN_FILES_PLUGIN_TYPE_FIND_JOB));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		gedit_find_in_files_plugin_find_job_unref (old);
	}
}


static void
gedit_find_in_files_plugin_find_job_class_init (GeditFindInFilesPluginFindJobClass * klass)
{
	gedit_find_in_files_plugin_find_job_parent_class = g_type_class_peek_parent (klass);
	((GeditFindInFilesPluginFindJobClass *) klass)->finalize = gedit_find_in_files_plugin_find_job_finalize;
	g_type_class_add_private (klass, sizeof (GeditFindInFilesPluginFindJobPrivate));
	gedit_find_in_files_plugin_find_job_signals[GEDIT_FIND_IN_FILES_PLUGIN_FIND_JOB_ON_MATCH_FOUND_SIGNAL] = g_signal_new ("on-match-found", GEDIT_FIND_IN_FILES_PLUGIN_TYPE_FIND_JOB, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__BOXED, G_TYPE_NONE, 1, GEDIT_FIND_IN_FILES_PLUGIN_TYPE_RESULT);
	gedit_find_in_files_plugin_find_job_signals[GEDIT_FIND_IN_FILES_PLUGIN_FIND_JOB_ON_SEARCH_FINISHED_SIGNAL] = g_signal_new ("on-search-finished", GEDIT_FIND_IN_FILES_PLUGIN_TYPE_FIND_JOB, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
}


static void
gedit_find_in_files_plugin_find_job_instance_init (GeditFindInFilesPluginFindJob * self)
{
	GAsyncQueue* _tmp0_;
	self->priv = GEDIT_FIND_IN_FILES_PLUGIN_FIND_JOB_GET_PRIVATE (self);
	_tmp0_ = g_async_queue_new_full (_g_free0_);
	self->priv->scan_queue = _tmp0_;
	g_rec_mutex_init (&self->priv->__lock_running_workers);
	self->priv->running_workers = (guint) 0;
	self->priv->matcher = NULL;
	self->ref_count = 1;
}


static void
gedit_find_in_files_plugin_find_job_finalize (GeditFindInFilesPluginFindJob * obj)
{
	GeditFindInFilesPluginFindJob * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, GEDIT_FIND_IN_FILES_PLUGIN_TYPE_FIND_JOB, GeditFindInFilesPluginFindJob);
	g_signal_handlers_destroy (self);
	_g_async_queue_unref0 (self->priv->scan_queue);
	__g_list_free__g_thread_unref0_0 (self->priv->thread_workers);
	g_rec_mutex_clear (&self->priv->__lock_running_workers);
	_g_object_unref0 (self->priv->matcher);
	_g_object_unref0 (self->priv->cancellable);
	_g_free0 (self->priv->_needle);
}


GType
gedit_find_in_files_plugin_find_job_get_type (void)
{
	return gedit_find_in_files_plugin_find_job_type_id;
}


GType
gedit_find_in_files_plugin_find_job_register_type (GTypeModule * module)
{
	static const GTypeValueTable g_define_type_value_table = { gedit_find_in_files_plugin_value_find_job_init, gedit_find_in_files_plugin_value_find_job_free_value, gedit_find_in_files_plugin_value_find_job_copy_value, gedit_find_in_files_plugin_value_find_job_peek_pointer, "p", gedit_find_in_files_plugin_value_find_job_collect_value, "p", gedit_find_in_files_plugin_value_find_job_lcopy_value };
	static const GTypeInfo g_define_type_info = { sizeof (GeditFindInFilesPluginFindJobClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) gedit_find_in_files_plugin_find_job_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (GeditFindInFilesPluginFindJob), 0, (GInstanceInitFunc) gedit_find_in_files_plugin_find_job_instance_init, &g_define_type_value_table };
	static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
	gedit_find_in_files_plugin_find_job_type_id = g_type_register_fundamental (g_type_fundamental_next (), "GeditFindInFilesPluginFindJob", &g_define_type_info, &g_define_type_fundamental_info, 0);
	return gedit_find_in_files_plugin_find_job_type_id;
}


gpointer
gedit_find_in_files_plugin_find_job_ref (gpointer instance)
{
	GeditFindInFilesPluginFindJob * self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void
gedit_find_in_files_plugin_find_job_unref (gpointer instance)
{
	GeditFindInFilesPluginFindJob * self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		GEDIT_FIND_IN_FILES_PLUGIN_FIND_JOB_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}



